<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Canvas テトリス (ストック機能)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-color: #1a202c;
            --surface-color: #2d3748;
            --border-color: #4a5568;
            --text-primary: #e2e8f0;
            --text-secondary: #a0aec0;
            --accent-color: #4299e1;
            --button-bg: #4a5568;
            --button-active-bg: #718096;
            --button-disabled-bg: #2d3748; /* ストック不可時のボタン背景 */
            --button-disabled-text: #718096; /* ストック不可時のボタン文字色 */
        }

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-primary);
            overflow: hidden;
            padding: 0.5rem;
            box-sizing: border-box;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            max-width: 400px;
        }

        .main-content {
            display: flex;
            width: 100%;
            gap: 0.5rem;
            align-items: flex-start;
        }

        #gameCanvas {
            border: 2px solid var(--border-color);
            background-color: var(--surface-color);
            border-radius: 8px;
        }

        .info-panel {
            flex-grow: 1;
            padding: 0.5rem;
            background-color: var(--surface-color);
            border-radius: 8px;
            border: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 0.5rem; /* 各情報要素間のギャップ */
            font-size: 0.875rem;
            min-width: 100px;
        }

        .info-section { /* スコア、次のミノ、ストックミノの各セクション */
            display: flex;
            flex-direction: column;
            align-items: center; /* 中央揃え */
        }


        .info-panel h2 {
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 0.1rem; /* h2とCanvasの間のマージンを詰める */
            color: var(--text-secondary);
            text-align: center;
        }

        .info-panel p#score { /* スコア専用スタイル */
            font-size: 1.1rem;
            color: var(--text-primary);
            font-weight: bold;
            text-align: center;
            margin-bottom: 0.25rem;
        }

        #nextCanvas, #stockCanvas {
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
            border-radius: 4px;
            display: block;
            margin: 0 auto 0.25rem; /* Canvasと次の要素(ボタンなど)の間のマージン */
        }

        #btnStock {
            background-color: var(--button-bg);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 80%; /* ボタン幅を調整 */
            margin: 0 auto; /* 中央揃え */
            display: block; /* margin autoを効かせるため */
        }

        #btnStock:active {
            background-color: var(--button-active-bg);
        }
        #btnStock:disabled {
            background-color: var(--button-disabled-bg);
            color: var(--button-disabled-text);
            cursor: not-allowed;
        }


        .controls-container { /* ... (前回と同様) ... */
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 420px;
            padding: 0.5rem 0;
            margin-top: auto;
        }
        .d-pad-controls, .action-buttons { /* ... (前回と同様) ... */
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .d-pad-controls button { /* ... (前回と同様) ... */
            background-color: var(--button-bg); color: white; border: none; border-radius: 8px;
            width: 60px; height: 60px; font-size: 1.5rem; display: flex; justify-content: center;
            align-items: center; transition: background-color 0.2s; touch-action: manipulation;
        }
        .d-pad-controls button:active { background-color: var(--button-active-bg); }
        .action-buttons { /* ... (前回と同様) ... */
            display: grid; grid-template-areas: ". rotate-cw ." "rotate-ccw . hard-drop" ". soft-drop .";
            grid-template-columns: repeat(3, 50px); grid-template-rows: repeat(3, 50px);
            gap: 5px; justify-content: center; align-content: center; transform: scale(0.9);
        }
        .action-buttons button { /* ... (前回と同様) ... */
            background-color: var(--button-bg); color: white; border: none; border-radius: 50%;
            width: 100%; height: 100%; font-size: 1.2rem; display: flex; justify-content: center;
            align-items: center; transition: background-color 0.2s; touch-action: manipulation;
        }
        .action-buttons button:active { background-color: var(--button-active-bg); }
        #btnRotateCW { grid-area: rotate-cw; }
        #btnRotateCCW { grid-area: rotate-ccw; }
        #btnSoftDrop { grid-area: soft-drop; }
        #btnHardDropAction { grid-area: hard-drop; }

        .game-over-message { /* ... (前回と同様) ... */
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85); padding: 1.5rem; border-radius: 10px;
            text-align: center; z-index: 100; color: white; border: 2px solid #E53E3E;
            width: 90%; max-width: 350px;
        }
        .game-over-message h2 { font-size: 1.8rem; color: #FC8181; margin-bottom: 1rem; }
        .game-over-message p { font-size: 1rem; margin-bottom: 1.25rem; }
        .game-over-message button {
            padding: 0.6rem 1rem; font-size: 0.9rem; background-color: #48BB78;
            color: white; border: none; border-radius: 5px; cursor: pointer;
            transition: background-color 0.3s;
        }
        .game-over-message button:hover { background-color: #38A169; }
        .hidden { display: none !important; }

        .controls-info { display: none; } /* スマホではキーボード説明非表示 */
        @media (min-width: 768px) { /* PCでは表示 */
            .controls-info { /* ... (前回と同様) ... */
                display: block; margin-top: 1rem; padding: 0.75rem; background-color: var(--surface-color);
                border-radius: 8px; border: 1px solid var(--border-color); font-size: 0.875rem;
            }
            .controls-info h3 { font-size: 1rem; font-weight: bold; margin-bottom: 0.5rem; color: var(--text-secondary); }
            .controls-info ul { list-style-type: none; padding-left: 0; }
            .controls-info li { margin-bottom: 0.25rem; color: var(--text-primary); }
            .game-area { flex-direction: row; align-items: flex-start; max-width: none;}
            .main-content { flex-direction: row; }
            .info-panel { flex-grow: 0; width: 200px; }
            .controls-container { justify-content: center; gap: 2rem; }
        }
    </style>
</head>
<body>
    <div class="game-area">
        <div class="main-content">
            <canvas id="gameCanvas"></canvas>
            <div class="info-panel">
                <div class="info-section">
                    <h2>スコア</h2>
                    <p id="score">0</p>
                </div>
                <div class="info-section">
                    <h2>次のミノ</h2>
                    <canvas id="nextCanvas"></canvas>
                </div>
                <div class="info-section">
                    <h2>ストック</h2>
                    <canvas id="stockCanvas"></canvas>
                    <button id="btnStock">ストック</button>
                </div>
                <div class="controls-info"> <h3>操作方法 (キーボード)</h3>
                    <ul>
                        <li>↑ / X : 即落下</li>
                        <li>← / Z : 左回転</li>
                        <li>→ / C : 右回転</li>
                        <li>↓ : 高速落下</li>
                        <li>A / ←(key) : 左移動</li>
                        <li>D / →(key) : 右移動</li>
                        <li>Space / S : ストック</li>
                        <li>R : (ゲームオーバー時) リスタート</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="controls-container">
        <div class="d-pad-controls">
            <button id="btnMoveLeftPad">◀</button>
            <button id="btnMoveRightPad">▶</button>
        </div>
        <div class="action-buttons">
            <button id="btnRotateCW">↻</button>
            <button id="btnRotateCCW">↺</button>
            <button id="btnSoftDrop">↓</button>
            <button id="btnHardDropAction">⏬</button>
        </div>
    </div>

    <div id="gameOverScreen" class="game-over-message hidden">
        <h2>ゲームオーバー</h2>
        <p id="finalScore">最終スコア: 0</p>
        <button id="restartButton">リスタート (R)</button>
    </div>

    <script>
        // --- 定数 ---
        const COLS = 10; const ROWS = 20; let BLOCK_SIZE = 20;
        const NEXT_COLS = 4; const NEXT_ROWS = 4; let NEXT_BLOCK_SIZE = 12;
        const STOCK_COLS = 4; const STOCK_ROWS = 4; let STOCK_BLOCK_SIZE = 10; // ストック用サイズ

        const COLORS = { /* ... (前回と同様) ... */
            0: getComputedStyle(document.documentElement).getPropertyValue('--surface-color').trim(),
            'I': '#38B2AC', 'O': '#F6E05E', 'T': '#A0AEC0',
            'S': '#68D391', 'Z': '#FC8181', 'J': '#63B3ED', 'L': '#F6AD55',
            'GHOST': 'rgba(237, 242, 247, 0.15)'
        };
        const BORDER_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
        const TETROMINOES = { /* ... (前回と同様) ... */
            'I': { shape: [[[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], [[0,1,0,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]], [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]], [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]]], color: 'I', spawnOffset: {x: 0, y: -1}},
            'O': { shape: [[[1,1], [1,1]]], color: 'O', spawnOffset: {x: 0, y: 0}},
            'T': { shape: [[[0,1,0], [1,1,1], [0,0,0]], [[0,1,0], [0,1,1], [0,1,0]], [[0,0,0], [1,1,1], [0,1,0]], [[0,1,0], [1,1,0], [0,1,0]]], color: 'T', spawnOffset: {x: 0, y: 0}},
            'S': { shape: [[[0,1,1], [1,1,0], [0,0,0]], [[0,1,0], [0,1,1], [0,0,1]]], color: 'S', spawnOffset: {x: 0, y: 0}},
            'Z': { shape: [[[1,1,0], [0,1,1], [0,0,0]], [[0,0,1], [0,1,1], [0,1,0]]], color: 'Z', spawnOffset: {x: 0, y: 0}},
            'J': { shape: [[[1,0,0], [1,1,1], [0,0,0]], [[0,1,1], [0,1,0], [0,1,0]], [[0,0,0], [1,1,1], [0,0,1]], [[0,1,0], [0,1,0], [1,1,0]]], color: 'J', spawnOffset: {x: 0, y: 0}},
            'L': { shape: [[[0,0,1], [1,1,1], [0,0,0]], [[0,1,0], [0,1,0], [0,1,1]], [[0,0,0], [1,1,1], [1,0,0]], [[1,1,0], [0,1,0], [0,1,0]]], color: 'L', spawnOffset: {x: 0, y: 0}}
        };


        // --- グローバル変数 ---
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas'); const nextCtx = nextCanvas.getContext('2d');
        const stockCanvas = document.getElementById('stockCanvas'); const stockCtx = stockCanvas.getContext('2d'); // ストック用Canvas
        const scoreElement = document.getElementById('score');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const btnStockElement = document.getElementById('btnStock'); // ストックボタン要素

        // Touch Control Buttons (前回と同様)
        const btnMoveLeftPad = document.getElementById('btnMoveLeftPad');
        const btnMoveRightPad = document.getElementById('btnMoveRightPad');
        const btnRotateCW = document.getElementById('btnRotateCW');
        const btnRotateCCW = document.getElementById('btnRotateCCW');
        const btnSoftDrop = document.getElementById('btnSoftDrop');
        const btnHardDropAction = document.getElementById('btnHardDropAction');


        let board;
        let currentTetromino;
        let nextTetromino;
        let stockTetromino = null; // ストックされたミノ
        let canStockThisTurn = true; // このターンでストック可能かどうかのフラグ
        let score;
        let gameOver;
        let fallTime;
        let fallSpeedNormal = 700;
        let fallSpeedSoftDrop = 70;
        let currentFallSpeed;
        let animationFrameId;
        let isSoftDropping = false;

        // --- 初期化 & リサイズ処理 ---
        function setupCanvasSizes() {
            const gameArea = document.querySelector('.game-area');
            const controlsContainer = document.querySelector('.controls-container');
            const availableHeight = window.innerHeight - controlsContainer.offsetHeight - (parseInt(getComputedStyle(document.body).paddingTop) * 2) - (parseInt(getComputedStyle(gameArea).gap) || 0) - 20;
            const availableWidth = gameArea.offsetWidth;

            const canvasWidthBasedOnHeight = (availableHeight / ROWS) * COLS;

            if (canvasWidthBasedOnHeight <= availableWidth * 0.60) { // Canvasがメインコンテンツの60%以下
                 BLOCK_SIZE = Math.floor(availableHeight / ROWS);
            } else {
                 BLOCK_SIZE = Math.floor((availableWidth * 0.60) / COLS);
            }
            BLOCK_SIZE = Math.max(10, BLOCK_SIZE);

            const mainContentWidth = COLS * BLOCK_SIZE;
            document.querySelector('.main-content').style.width = `${mainContentWidth + (availableWidth * 0.40) + 10}px`;
            canvas.width = mainContentWidth;
            canvas.height = ROWS * BLOCK_SIZE;
            ctx.scale(BLOCK_SIZE, BLOCK_SIZE);

            const infoPanel = document.querySelector('.info-panel');
            NEXT_BLOCK_SIZE = Math.floor( (infoPanel.clientWidth * 0.5) / NEXT_COLS ); // 少し小さく
            NEXT_BLOCK_SIZE = Math.max(8, NEXT_BLOCK_SIZE);
            STOCK_BLOCK_SIZE = NEXT_BLOCK_SIZE; // ストックも同じサイズに

            nextCanvas.width = NEXT_COLS * NEXT_BLOCK_SIZE;
            nextCanvas.height = NEXT_ROWS * NEXT_BLOCK_SIZE;
            if (nextCanvas.width > 0 && nextCanvas.height > 0) {
                 nextCtx.scale(NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);
            }

            stockCanvas.width = STOCK_COLS * STOCK_BLOCK_SIZE;
            stockCanvas.height = STOCK_ROWS * STOCK_BLOCK_SIZE;
            if (stockCanvas.width > 0 && stockCanvas.height > 0) {
                 stockCtx.scale(STOCK_BLOCK_SIZE, STOCK_BLOCK_SIZE);
            }
        }

        function init() {
            setupCanvasSizes();
            window.addEventListener('resize', () => {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                nextCtx.setTransform(1, 0, 0, 1, 0, 0);
                stockCtx.setTransform(1, 0, 0, 1, 0, 0); // ストックCanvasもリセット
                setupCanvasSizes();
                if (!gameOver) {
                    draw();
                    drawNextTetromino();
                    drawStockTetromino(); // ストックも再描画
                }
            });
            resetGame();
        }

        function resetGame() {
            board = createBoard();
            score = 0;
            updateScore();
            gameOver = false;
            currentFallSpeed = fallSpeedNormal;
            isSoftDropping = false;
            fallTime = 0;
            stockTetromino = null; // ストックをリセット
            canStockThisTurn = true; // ストック可能状態に
            btnStockElement.disabled = false; // ストックボタンを有効化
            spawnNewTetromino(); // 1つ目
            spawnNewTetromino(); // 2つ目 (nextTetrominoに入る)

            drawStockTetromino(); // 初期ストック表示（空のはず）
            gameOverScreen.classList.add('hidden');
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }

        function createBoard() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }

        function spawnNewTetromino(fromStock = false) {
            if (gameOver) return;

            if (fromStock && stockTetromino) { // ストックから出す場合
                currentTetromino = stockTetromino;
                stockTetromino = null; // ストックを空にする
            } else { // 通常の新しいミノ
                currentTetromino = nextTetromino;
                const types = 'IOTSLJZ';
                const type = types[Math.floor(Math.random() * types.length)];
                const tetrominoData = TETROMINOES[type];
                nextTetromino = {
                    shape: tetrominoData.shape[0], // 初期形状
                    allShapes: tetrominoData.shape,
                    color: tetrominoData.color,
                    // x, y は currentTetromino にセットする際に決定
                    rotation: 0
                };
            }

            if (currentTetromino) {
                 currentTetromino.x = Math.floor(COLS / 2) - Math.floor(currentTetromino.shape[0].length / 2);
                 currentTetromino.y = TETROMINOES[currentTetromino.color].spawnOffset.y;
                 if (checkCollision(currentTetromino.shape, currentTetromino.x, currentTetromino.y)) {
                    gameOver = true;
                }
            } else if (!fromStock) { // 通常スポーンでcurrentTetrominoがnullになるのはおかしい (nextが空だった場合など)
                 console.error("Failed to spawn new tetromino. Next tetromino might be undefined.");
                 gameOver = true; // 安全のためゲームオーバー
            }

            drawNextTetromino();
            drawStockTetromino(); // ストック状態が変わった可能性があるので再描画
        }

        // --- ストック機能 ---
        function handleStock() {
            if (gameOver || !canStockThisTurn || !currentTetromino) return;

            if (stockTetromino === null) { // ストックが空の場合
                stockTetromino = { ...currentTetromino, shape: TETROMINOES[currentTetromino.color].shape[0], rotation: 0 }; // 初期回転でストック
                spawnNewTetromino(); // 次のミノを落下させる
            } else { // ストックにミノがある場合
                const temp = currentTetromino;
                currentTetromino = { ...stockTetromino, shape: TETROMINOES[stockTetromino.color].shape[0], rotation: 0 }; // ストックから出す時は初期回転
                stockTetromino = { ...temp, shape: TETROMINOES[temp.color].shape[0], rotation: 0 }; // 現在のミノを初期回転でストック

                // ストックから出したミノの初期位置を設定
                currentTetromino.x = Math.floor(COLS / 2) - Math.floor(currentTetromino.shape[0].length / 2);
                currentTetromino.y = TETROMINOES[currentTetromino.color].spawnOffset.y;

                if (checkCollision(currentTetromino.shape, currentTetromino.x, currentTetromino.y)) {
                    gameOver = true; // 入れ替えた結果、即衝突ならゲームオーバー
                }
            }
            canStockThisTurn = false; // このターンはもうストックできない
            btnStockElement.disabled = true; // ボタンを無効化
            fallTime = 0; // 落下タイマーリセットして即座の落下を防ぐ（好みで調整）
            drawStockTetromino();
            drawNextTetromino(); // currentが変わったのでnextも再描画されるべき spawnNewTetromino内で処理
        }


        // --- ゲームロジック (変更なしの部分は省略) ---
        function moveTetromino(dx, dy) { /* ... (前回と同様) ... */
            if (!currentTetromino || gameOver) return false;
            if (!checkCollision(currentTetromino.shape, currentTetromino.x + dx, currentTetromino.y + dy)) {
                currentTetromino.x += dx;
                currentTetromino.y += dy;
                return true;
            }
            return false;
        }
        function rotateTetrominoLogic(clockwise = true) { /* ... (前回と同様) ... */
            if (!currentTetromino || gameOver) return;
            const originalRotation = currentTetromino.rotation;
            const originalX = currentTetromino.x;
            const numRotations = currentTetromino.allShapes.length;

            if (clockwise) {
                currentTetromino.rotation = (currentTetromino.rotation + 1) % numRotations;
            } else {
                currentTetromino.rotation = (currentTetromino.rotation - 1 + numRotations) % numRotations;
            }
            const nextShape = currentTetromino.allShapes[currentTetromino.rotation];

            let kicks = [0, 1, -1, 2, -2];
            if (currentTetromino.color === 'I') { kicks.push(3, -3); }

            let success = false;
            for (const kick of kicks) {
                if (!checkCollision(nextShape, currentTetromino.x + kick, currentTetromino.y)) {
                    currentTetromino.x += kick;
                    currentTetromino.shape = nextShape;
                    success = true;
                    break;
                }
            }
            if (!success) {
                currentTetromino.rotation = originalRotation;
                currentTetromino.x = originalX;
                currentTetromino.shape = currentTetromino.allShapes[originalRotation];
            }
        }
        function hardDropAction() { /* ... (前回と同様) ... */
            if (!currentTetromino || gameOver) return;
            let originalY = currentTetromino.y;
            while (moveTetromino(0, 1)) { /* empty */ }
            if (currentTetromino.y > originalY) {
                 score += Math.max(1, (currentTetromino.y - originalY));
                 updateScore();
            }
            lockTetromino();
        }
        function checkCollision(shape, x, y) { /* ... (前回と同様) ... */
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const newX = x + c;
                        const newY = y + r;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >=0 && board[newY][newX])) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function lockTetromino() {
            if (!currentTetromino) return;
            currentTetromino.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value && currentTetromino.y + r >= 0) {
                        if (currentTetromino.y + r < ROWS) {
                           board[currentTetromino.y + r][currentTetromino.x + c] = currentTetromino.color;
                        }
                    }
                });
            });
            clearLines();
            canStockThisTurn = true; // ミノがロックされたので再度ストック可能に
            btnStockElement.disabled = false; // ストックボタンを有効化
            spawnNewTetromino();
            if (gameOver) return;

            if (!isSoftDropping) currentFallSpeed = fallSpeedNormal;
            fallTime = 0;
        }
        function clearLines() { /* ... (前回と同様) ... */
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    linesCleared++;
                    board.splice(r, 1);
                    board.unshift(Array(COLS).fill(0));
                    r++;
                }
            }
            if (linesCleared > 0) {
                if (linesCleared === 1) score += 100;
                else if (linesCleared === 2) score += 300;
                else if (linesCleared === 3) score += 500;
                else if (linesCleared >= 4) score += 800 * linesCleared;
                updateScore();
            }
        }
        function updateScore() { scoreElement.textContent = score; }

        // --- 描画処理 ---
        function draw() { /* ... (前回と同様) ... */
            ctx.fillStyle = COLORS[0];
            ctx.fillRect(0, 0, COLS, ROWS);
            drawBoard();
            if (currentTetromino && !gameOver) {
                drawGhostTetromino();
                drawTetrominoShape(currentTetromino, ctx, BLOCK_SIZE);
            }
        }
        function drawBoard() { /* ... (前回と同様) ... */
            board.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value !== 0) {
                        drawBlock(ctx, c, r, COLORS[value], BLOCK_SIZE);
                    }
                });
            });
        }

        function drawTetrominoShape(tetromino, targetCtx, blockSizeToUse) {
            if (!tetromino || !tetromino.shape) return; // 安全チェック
            const colorKey = tetromino.color;
            const colorValue = COLORS[colorKey] || COLORS['I']; // 不明な色ならIミノの色

            tetromino.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value) {
                        if (tetromino.y + r >= 0 || targetCtx === nextCtx || targetCtx === stockCtx) { // メイン盤面以外はy座標チェック不要
                            drawBlock(targetCtx, tetromino.x + c, tetromino.y + r, colorValue, blockSizeToUse);
                        }
                    }
                });
            });
        }

        function drawGhostTetromino() { /* ... (前回と同様) ... */
            if (!currentTetromino || gameOver) return;
            let ghostY = currentTetromino.y;
            while (!checkCollision(currentTetromino.shape, currentTetromino.x, ghostY + 1)) {
                ghostY++;
            }
            currentTetromino.shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value) {
                        if (ghostY + r >= 0) {
                           drawBlock(ctx, currentTetromino.x + c, ghostY + r, COLORS.GHOST, BLOCK_SIZE);
                        }
                    }
                });
            });
        }

        function drawBlock(targetCtx, x, y, color, blockSizeToUse) {
            targetCtx.fillStyle = color;
            // targetCtxのスケールは既に設定されているので、座標はそのまま、サイズは1x1
            targetCtx.fillRect(x, y, 1, 1);
            targetCtx.strokeStyle = BORDER_COLOR;
            // 線の太さは、基準となるブロックサイズ(e.g., 20px)に対する相対値で設定すると見栄えが良い
            targetCtx.lineWidth = 0.05 * (20 / blockSizeToUse); // 基準20pxで0.05なら、サイズに応じて調整
            targetCtx.strokeRect(x, y, 1, 1);
        }

        function drawPreviewTetromino(tetromino, targetCtx, previewCols, previewRows, blockSizeToUse) {
            if (targetCtx.canvas.width <= 0 || targetCtx.canvas.height <= 0 || blockSizeToUse <= 0) return;

            // スケール再設定
            targetCtx.setTransform(1,0,0,1,0,0);
            targetCtx.scale(blockSizeToUse, blockSizeToUse);

            targetCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-color').trim();
            targetCtx.fillRect(0, 0, previewCols, previewRows);

            if (tetromino) {
                const shape = TETROMINOES[tetromino.color].shape[0]; // 必ず初期形状で表示
                const color = COLORS[tetromino.color];
                const shapeHeight = shape.length;
                const shapeWidth = shape[0].length;
                const offsetX = (previewCols - shapeWidth) / 2;
                const offsetY = (previewRows - shapeHeight) / 2;

                shape.forEach((row, r) => {
                    row.forEach((value, c) => {
                        if (value) {
                            // プレビュー用の描画（x,yはオフセットからの相対位置）
                            drawBlock(targetCtx, offsetX + c, offsetY + r, color, blockSizeToUse);
                        }
                    });
                });
            }
        }

        function drawNextTetromino() {
            drawPreviewTetromino(nextTetromino, nextCtx, NEXT_COLS, NEXT_ROWS, NEXT_BLOCK_SIZE);
        }

        function drawStockTetromino() {
            drawPreviewTetromino(stockTetromino, stockCtx, STOCK_COLS, STOCK_ROWS, STOCK_BLOCK_SIZE);
        }


        function showGameOverScreen() { /* ... (前回と同様) ... */
            finalScoreElement.textContent = `最終スコア: ${score}`;
            gameOverScreen.classList.remove('hidden');
            btnStockElement.disabled = true; // ゲームオーバー時もストックボタン無効
        }

        // --- ゲームループ ---
        let lastTime = 0;
        function gameLoop(timestamp = 0) { /* ... (前回と同様) ... */
            if (gameOver) {
                draw();
                showGameOverScreen();
                return;
            }

            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            fallTime += deltaTime;

            if (fallTime >= currentFallSpeed) {
                fallTime = 0;
                if (!moveTetromino(0, 1)) {
                    lockTetromino();
                    if (gameOver) {
                        draw();
                        showGameOverScreen();
                        return;
                    }
                }
            }
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- イベントリスナー ---
        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            if (gameOver) {
                if (event.key.toUpperCase() === 'R') resetGame();
                return;
            }
            if (!currentTetromino) return;

            // キーボード操作にストック追加 (例: Sキー or Spaceキー)
            if (event.key.toUpperCase() === 'S' || event.code === 'Space') {
                event.preventDefault(); // Spaceでの画面スクロールを防ぐ
                handleStock();
                return; // ストック操作後は他の操作を無視
            }
            // キーボード操作に回転キー追加 (例: Z, C, X)
            // Xキーでハードドロップも良いかも
            if (event.key.toUpperCase() === 'X' || event.key.toUpperCase() === 'ARROWUP') {
                 hardDropAction(); return;
            }
            if (event.key.toUpperCase() === 'Z') {
                 rotateTetrominoLogic(false); return; // 反時計回り
            }
             if (event.key.toUpperCase() === 'C') {
                 rotateTetrominoLogic(true); return; // 時計回り
            }


            switch (event.key.toUpperCase()) {
                // case 'ARROWLEFT': rotateTetrominoLogic(false); break; // Zに割り当てたのでコメントアウト
                // case 'ARROWRIGHT': rotateTetrominoLogic(true); break; // Cに割り当てたのでコメントアウト
                case 'ARROWLEFT': // Aキーも左移動
                case 'A':
                    moveTetromino(-1, 0); break;
                case 'ARROWRIGHT': // Dキーも右移動
                case 'D':
                    moveTetromino(1, 0); break;
                case 'ARROWDOWN':
                    if (!isSoftDropping) {
                        isSoftDropping = true;
                        currentFallSpeed = fallSpeedSoftDrop;
                        score += 1; updateScore();
                        if (moveTetromino(0, 1)) fallTime = 0;
                    }
                    break;
                // case 'ARROWUP': hardDropAction(); break; // Xに割り当てたのでコメントアウト
            }
        });

        document.addEventListener('keyup', (event) => { /* ... (前回と同様) ... */
            if (event.key.toUpperCase() === 'ARROWDOWN') {
                isSoftDropping = false;
                currentFallSpeed = fallSpeedNormal;
            }
        });

        // Touch controls
        btnMoveLeftPad.addEventListener('click', () => moveTetromino(-1, 0));
        btnMoveRightPad.addEventListener('click', () => moveTetromino(1, 0));
        btnRotateCW.addEventListener('click', () => rotateTetrominoLogic(true));
        btnRotateCCW.addEventListener('click', () => rotateTetrominoLogic(false));
        btnHardDropAction.addEventListener('click', hardDropAction);
        btnStockElement.addEventListener('click', handleStock); // ストックボタン

        btnSoftDrop.addEventListener('touchstart', (e) => { /* ... (前回と同様) ... */
            e.preventDefault(); if (gameOver || !currentTetromino) return;
            isSoftDropping = true; currentFallSpeed = fallSpeedSoftDrop;
            score += 1; updateScore(); if (moveTetromino(0, 1)) fallTime = 0;
        });
        btnSoftDrop.addEventListener('touchend', (e) => { /* ... (前回と同様) ... */
            e.preventDefault(); if (gameOver || !currentTetromino) return;
            isSoftDropping = false; currentFallSpeed = fallSpeedNormal;
        });
        btnSoftDrop.addEventListener('mousedown', (e) => { /* ... (前回と同様) ... */
            if (e.button !== 0) return; e.preventDefault(); if (gameOver || !currentTetromino) return;
            isSoftDropping = true; currentFallSpeed = fallSpeedSoftDrop;
            score += 1; updateScore(); if (moveTetromino(0, 1)) fallTime = 0;
        });
        btnSoftDrop.addEventListener('mouseup', (e) => { /* ... (前回と同様) ... */
            if (e.button !== 0) return; e.preventDefault(); if (gameOver || !currentTetromino) return;
            isSoftDropping = false; currentFallSpeed = fallSpeedNormal;
        });
        btnSoftDrop.addEventListener('mouseleave', (e) => { /* ... (前回と同様) ... */
            if (isSoftDropping && (e.buttons === 1 || e.type === 'touchcancel')) {
                isSoftDropping = false; currentFallSpeed = fallSpeedNormal;
            }
        });

        restartButton.addEventListener('click', resetGame);

        // --- ゲーム開始 ---
        init();
    </script>
</body>
</html>